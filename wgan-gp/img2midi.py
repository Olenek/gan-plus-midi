import numpy as np
from PIL import Image
from music21 import instrument, note, stream

lowerBoundNote = 0


def column2notes(column, contrast_percentage):
    notes = []
    for i in range(len(column)):
        if column[i] >= 255 * contrast_percentage / 100.:
            notes.append(i + lowerBoundNote)
    return notes


resolution = 0.25


def updateNotes(newNotes, prevNotes):
    res = {}
    for note in newNotes:
        if note in prevNotes:
            res[note] = prevNotes[note] + resolution
        else:
            res[note] = resolution
    return res


def image2midi(image_path, contrast_percentage=None):
    with Image.open(image_path) as image:
        im_arr = np.frombuffer(image.tobytes(), dtype=np.uint8)
        try:
            im_arr = im_arr.reshape((image.size[1], image.size[0]))
        except:
            im_arr = im_arr.reshape((image.size[1], image.size[0], 3))
            im_arr = np.dot(im_arr, [1, 1, 1]) / 3.0

    """ convert the output from the prediction to notes and create a midi file
        from the notes """
    offset = 0
    output_notes = []

    # create note and chord objects based on the values generated by the model

    prev_notes = updateNotes(im_arr.T[0, :], {})
    if contrast_percentage is None:
        _contrast = 80
        _suffux = ""
    else:
        _suffix = f"_{contrast_percentage}"

    for column in im_arr.T[1:, :]:
        notes = column2notes(column, _contrast)
        # pattern is a chord
        notes_in_chord = notes
        old_notes = prev_notes.keys()
        for old_note in old_notes:
            if not old_note in notes_in_chord:
                new_note = note.Note(old_note, quarterLength=prev_notes[old_note])
                new_note.storedInstrument = instrument.Piano()
                if offset - prev_notes[old_note] >= 0:
                    new_note.offset = offset - prev_notes[old_note]
                    output_notes.append(new_note)
                elif offset == 0:
                    new_note.offset = offset
                    output_notes.append(new_note)
                else:
                    print(offset, prev_notes[old_note], old_note)

        prev_notes = updateNotes(notes_in_chord, prev_notes)

        # increase offset each iteration so that notes do not stack
        offset += resolution

    for old_note in prev_notes.keys():
        new_note = note.Note(old_note, quarterLength=prev_notes[old_note])
        new_note.storedInstrument = instrument.Piano()
        new_note.offset = offset - prev_notes[old_note]

        output_notes.append(new_note)

    prev_notes = updateNotes(notes_in_chord, prev_notes)

    midi_stream = stream.Stream(output_notes)

    midi_stream.write('midi', fp=image_path.replace(".png", f'{_suffix}.mid'))
